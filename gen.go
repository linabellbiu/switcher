package main

import (
	"bufio"
	"bytes"
	"errors"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/wangxudong123/switcher/tool"

	"github.com/wangxudong123/switcher/model"

	"golang.org/x/mod/modfile"
)

type generator struct {
	buf         bytes.Buffer
	indent      string
	outFilePath string
	pkg         string
	mockType    string
	isHead      bool
}

func (g *generator) Generate(pkg *model.Package, outFilePath string) error {
	g.pkg = pkg.Name
	g.outFilePath = outFilePath

	g.generateHead(g.pkg, outFilePath, pkg.Imports)
	for _, outStruct := range pkg.Struct {
		g.structName(outStruct.Name, outStruct.Field)
		g.funcName(outStruct.Name, g.mockType, outStruct.OldName, outStruct.Field)
	}

	_, err := g.Output()
	if err != nil {
		return err
	}
	log.Println(fmt.Sprintf("[info] generate package:%s in %s", g.pkg, outFilePath))
	return nil
}

func (g *generator) generateHead(outputPkgName string, outputPackagePath string, imports []string) {
	p, err := parsePackageImport(outputPackagePath)
	if err != nil {
		panic(err)
	}
	ps := strings.Split(p, "/")
	if len(ps) > 1 {
		outputPkgName = ps[len(ps)-1]
	} else {
		outputPkgName = ps[0]
	}

	ok, err := duplicate(fmt.Sprintf("package %v", outputPkgName), g.outFilePath)
	if err != nil {
		log.Println("[warning]generateHead duplicate path :" + err.Error())
	}

	if ok {
		g.isHead = true
	}

	if !g.isHead {
		g.p("// Code generated by https://github.com/wangxudong123/switcher/")
		g.p("")
		g.p("package %v", outputPkgName)
		g.p("")
	}
	if len(imports) > 0 {
		g.mockType = g.pkg

		if !g.isHead {
			g.p("import (")
			g.in()
		}
		for _, pkgPath := range imports {
			if pkgPath == p {
				g.mockType = ""
				continue
			}
			if !g.isHead {
				g.p("%q", pkgPath)
			}
		}
		if !g.isHead {
			g.out()
			g.p(")")
		}
	}
}

func (g *generator) structName(name string, fields []model.Field) {
	ok, err := duplicate(fmt.Sprintf("type %v struct {", name), g.outFilePath)
	if err != nil {
		log.Println("[warning]structName duplicate path :" + err.Error())
	}
	if ok == true {
		return
	}

	g.p("type %v struct {", name)
	g.in()
	for _, field := range fields {
		g.p("%v %v", field.Name, field.Type)
	}
	g.out()
	g.p("}")
	g.p("")
}

func (g *generator) funcName(newStructName, pkgName string, oldStructNames []string, fields []model.Field) {
	if pkgName != "" {
		pkgName = pkgName + "."
	}

	for _, oldStructName := range oldStructNames {
		ok, err := duplicate(fmt.Sprintf("func New%vTo%v(data *%v%v) *%v {", oldStructName, newStructName, pkgName, oldStructName, newStructName), g.outFilePath)
		if err != nil {
			log.Println("[warning]funcName duplicate path :" + err.Error())
		}
		if ok {
			continue
		}

		g.p("func New%vTo%v(data *%v%v) *%v {", oldStructName, newStructName, pkgName, oldStructName, newStructName)
		g.p("return &%v{", newStructName)
		g.in()
		for _, field := range fields {
			g.p("%v : data.%v,", field.Name, field.Name)
		}
		g.out()
		g.in()
		g.p("}")
		g.out()
		g.p("}")
		g.p("")

		// 相反的
		g.p("func New%vTo%v(data *%v) *%v%v {", newStructName, oldStructName, newStructName, pkgName, oldStructName)
		g.p("return &%v%v{", pkgName, oldStructName)
		g.in()
		for _, field := range fields {
			g.p("%v : data.%v,", field.Name, field.Name)
		}
		g.out()
		g.in()
		g.p("}")
		g.out()
		g.p("}")
		g.p("")
	}
}

func (g *generator) p(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, g.indent+format+"\n", args...)
}

func (g *generator) in() {
	g.indent += "\t"
}

func (g *generator) out() {
	if len(g.indent) > 0 {
		g.indent = g.indent[0 : len(g.indent)-1]
	}
}

func (g *generator) Output() (n int, err error) {
	if g.outFilePath == "" {
		g.outFilePath = "./switcher/" + g.pkg + "/" + g.pkg + ".go"
	}

	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		log.Fatalf("Failed to format generated source code: %s\n%s", err, g.buf.String())
	}

	dst := os.Stdout
	// if len(g.dstFileName) > 0 {
	if err := os.MkdirAll(filepath.Dir(g.outFilePath), os.ModePerm); err != nil {
		log.Fatalf("Unable to create directory: %v", err)
	}
	var f *os.File
	// var err error
	if !g.isHead {
		f, err = os.Create(g.outFilePath)
	} else {
		f, err = os.OpenFile(g.outFilePath, os.O_RDWR|os.O_APPEND, 0o666)
	}

	if err != nil {
		log.Fatalf("Failed opening destination file: %v", err)
	}
	defer dst.Close()
	dst = f
	//}

	return dst.Write(src)
}

func (g *generator) packName() {
	s := strings.Split(g.outFilePath, ".")
	if len(s) > 1 {
		if s[len(s)-1] == "go" {
			s = strings.Split(g.outFilePath, "/")
			if len(s) == 1 || (len(s) == 2 && s[0] == ".") {
				g.pkg = "main"
			}
		}
	}
}

var errOutsideGoPath = errors.New("Source directory is outside GOPATH")

func parsePackageImport(srcDir string) (string, error) {
	re, _ := regexp.Compile("[_a-zA-Za-zA-z]+\\.[a-zA-Z]+")
	srcDir = strings.Trim(re.ReplaceAllString(srcDir, ""), " ")

	moduleMode := os.Getenv("GO111MODULE")
	// trying to find the module
	if moduleMode != "off" {
		currentDir := srcDir
		for {
			dat, err := ioutil.ReadFile(filepath.Join(currentDir, "go.mod"))
			if os.IsNotExist(err) {
				if currentDir == filepath.Dir(currentDir) {
					// at the root
					break
				}
				currentDir = filepath.Dir(currentDir)
				continue
			} else if err != nil {
				return "", err
			}
			modulePath := modfile.ModulePath(dat)
			return filepath.ToSlash(filepath.Join(modulePath, strings.TrimPrefix(srcDir, currentDir))), nil
		}
	}
	// fall back to GOPATH mode
	goPaths := os.Getenv("GOPATH")
	if goPaths == "" {
		return "", fmt.Errorf("GOPATH is not set")
	}
	goPathList := strings.Split(goPaths, string(os.PathListSeparator))
	for _, goPath := range goPathList {
		sourceRoot := filepath.Join(goPath, "src") + string(os.PathSeparator)
		if strings.HasPrefix(srcDir, sourceRoot) {
			return filepath.ToSlash(strings.TrimPrefix(srcDir, sourceRoot)), nil
		}
	}
	return "", errOutsideGoPath
}

func duplicate(text, path string) (bool, error) {
	_, err := os.Stat(path)
	if err != nil {
		if os.IsNotExist(err) {
			return false, nil
		}
		panic(fmt.Sprintf("file path err %v,path %v", err, path))
	}

	f, err := os.Open(path)
	if err != nil {
		return false, err
	}
	defer f.Close()

	var ok bool
	// 每行读取
	scanner := bufio.NewScanner(f)
	for scanner.Scan() {
		if strings.Contains(tool.DelExtraSpace(scanner.Text()), tool.DelExtraSpace(text)) {
			ok = true
			break
		}
	}

	if ok {
		return true, nil
	}

	return false, nil
}
